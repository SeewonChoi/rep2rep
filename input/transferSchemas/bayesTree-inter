import bayes
import probTree
import metaLogic
import transferSchemas/numNum-inter

typeSystem interBayesTreeT =
    imports bayes, probTree, metaLogicT
    types
    order

conSpec interBayesTree:interBayesTreeT =
    imports probTreeG, bayesG, interNumNum
    constructors
        match : [events,outcome] -> metaBool,
        encode : [probSys,tree] -> metaBool

tSchema eventA:(bayesG,probTreeG,interBayesTree) =
    source t:A:event
    target t':A:outcome
    antecedent
    consequent :metaTrue <- match[t:A:event,t':A:outcome]
    strength 1

tSchema eventB:(bayesG,probTreeG,interBayesTree) =
    source t:B:event
    target t':B:outcome
    antecedent
    consequent :metaTrue <- match[t:B:event,t':B:outcome]
    strength 1

tSchema notEvent:(bayesG,probTreeG,interBayesTree) =
    source t:event <- complement[t1:overline,t2:event]
    target t':outcome <- notOutcome[t1':outcome]
    antecedent :metaTrue <- match[t2:event,t1':outcome]
    consequent :metaTrue <- match[t:event,t':outcome]
    strength 1

tSchema makeEvent:(bayesG,probTreeG,interBayesTree) =
    source t:probEqn <- prob[t1:event,t2:numExp]
    target t':tree <- construct[t1':outcome,t2':numExp]
    antecedent :metaTrue <- match[t1:event,t1':outcome],
               :metaTrue <- equal[t2:numExp,t2':numExp]
    consequent :metaTrue <- encode[t:probEqn,t':tree]
    strength 1

tSchema makeCond:(bayesG,probTreeG,interBayesTree) =
    source t:probEqn <- prob[t1:condEvent <- condition[t11:event,t12:cond,t13:event],
                             t2:numExp]
    target t':tree <- addBranch[t1':tree <-construct[t11':outcome,t12':b:numExp],
                                t2':outcome,
                                t3':numExp]
    antecedent :metaTrue <- match[t13:event,t11':outcome],
               :metaTrue <- match[t11:event,t2':outcome],
               :metaTrue <- equal[t2:numExp,t3':numExp]
    consequent :metaTrue <- encode[t:probEqn,t':tree]
    strength 1

tSchema makeInter:(bayesG,probTreeG,interBayesTree) =
    source t:probEqn <- prob[t1:event <- infix[t11:event,t12:inter,t13:event],
                             t2:numExp]
    target t':tree <- addBranch[t1':tree <- construct[t11':outcome, t12':a:numExp],
                                t2':outcome, 
                                t3':numExp <- frac[t31':numExp,t32':div,t12':a:numExp]]
    antecedent :metaTrue <- match[t11:event,t11':outcome],
               :metaTrue <- match[t13:event,t2':outcome],
               :metaTrue <- equal[t2:numExp,t31':numExp]
    consequent :metaTrue <- encode[t:probEqn,t':tree]
    strength 1

tSchema resolveTree:(bayesG,probTreeG,interBayesTree) =
    source t:probSys <- addEqn[t1:probEqn,t2:probSys]
    target t':tree <- resolve[t1':tree,t2':tree]
    antecedent :metaTrue <- encode[t1:probEqn,t1':tree],
               :metaTrue <- encode[t2:probSys,t2':tree]
    consequent :metaTrue <- encode[t:probSys,t':tree]
    strength 1